# Plan 2.5: Debian Packaging and Release Automation

**Status**: Planning  
**Parent Document**: [Space Captain v0.1.0 PRD](../prd/version-0.1.0.md)  
**Scope**: Infrastructure and release engineering for v0.1.0

This plan outlines the implementation of Debian packaging for the Space Captain server and automated release workflows for multiple architectures. It extends the core v0.1.0 release with professional packaging and distribution capabilities.

---

## Phase 1: Debian Package Creation (Week 1)

### Goal
Create a proper Debian 12 package (.deb) that includes only the Space Captain server binary with appropriate system integration.

### Tasks

#### 1.1: Package Structure Setup
- Create `debian/` directory structure following Debian packaging standards
- Configure `debian/control` with package metadata:
  - Package name: `space-captain-server`
  - Version: Derived from current git tag
  - Architecture: `amd64` initially, later `arm64`
  - Dependencies: `libc6`, `libmbedtls14`
  - Description: "Space Captain MMO Server - High-performance space combat server"

#### 1.2: Build Configuration
- Create `debian/rules` for the build process
- Configure to use the existing Makefile with `make release` target
- Ensure proper installation paths:
  - Binary: `/usr/bin/space-captain-server`
  - Systemd service: `/lib/systemd/system/space-captain-server.service`

#### 1.3: System Integration
- Create systemd service file for the server:
  - Explicitly specify `User=space-captain` and `Group=space-captain`
  - Run as dedicated unprivileged system user (non-interactive)
  - Restart on failure with `Restart=on-failure` and `RestartSec=5`
  - StandardOutput=journal and StandardError=journal (systemd defaults)
  - No log file management needed - server outputs to stdout/stderr
  - Resource limits appropriate for high-connection-count server:
    - `LimitNOFILE=65536` for high connection counts
    - `PrivateTmp=yes` for security isolation
- Add postinst script for:
  - Creating system group and user with proper security settings:
    ```bash
    # Create system group if it doesn't exist
    if ! getent group space-captain >/dev/null; then
        addgroup --system space-captain
    fi
    # Create system user if it doesn't exist
    if ! getent passwd space-captain >/dev/null; then
        adduser --system --no-create-home --ingroup space-captain \
                --shell /usr/sbin/nologin space-captain
    fi
    ```
  - Enabling and starting systemd service
  - Setting proper permissions on any runtime directories
- Add prerm script for:
  - Stopping systemd service gracefully
  - Disabling service on package removal

#### 1.4: Docker Build Environment
- Create `docker/debian-build.dockerfile` based on `debian:12-slim`
- Install build dependencies: `build-essential`, `debhelper`, `libmbedtls-dev`
- Create build script that:
  - Mounts project directory into container
  - Builds the .deb package in isolated environment
  - Copies resulting package to host `dist/` directory

#### 1.4.1: Monitoring Integration
- **Prometheus Metrics Configuration**:
  - Add example configuration file at `/etc/space-captain/prometheus.conf`:
    ```yaml
    # Prometheus metrics endpoint configuration
    metrics:
      enabled: true
      port: 9100
      path: /metrics
      include_process_metrics: true
      include_connection_metrics: true
      include_game_metrics: true
    ```
  - Package configuration in `/usr/share/doc/space-captain-server/examples/`
  - Document available metrics:
    - `space_captain_connections_total` - Total connection count
    - `space_captain_active_connections` - Current active connections
    - `space_captain_messages_processed_total` - Messages processed by type
    - `space_captain_tick_duration_seconds` - Game tick processing time
    - `space_captain_memory_usage_bytes` - Process memory usage
    - `space_captain_cpu_usage_percent` - CPU utilization

- **Grafana Dashboard Template**:
  - Include `monitoring/grafana-dashboard.json` in package
  - Install to `/usr/share/space-captain-server/monitoring/`
  - Dashboard panels:
    - Connection metrics (current, total, rate)
    - Performance metrics (tick rate, latency)
    - Resource usage (CPU, memory, network)
    - Error rates and alerts
    - Message type distribution
  - Auto-import instructions in postinst script

- **Monitoring Best Practices Documentation**:
  - Create `docs/monitoring-guide.md` with:
    - Prometheus scrape configuration example:
      ```yaml
      scrape_configs:
        - job_name: 'space-captain'
          static_configs:
            - targets: ['localhost:9100']
          scrape_interval: 15s
      ```
    - Alert rule examples for common issues:
      - High connection count (>80% of limit)
      - Tick rate degradation (<55 ticks/second)
      - Memory usage growth
      - Connection error rates
    - Performance tuning based on metrics
    - Capacity planning guidelines

- **Systemd Integration for Monitoring**:
  - Add prometheus exporter socket activation:
    ```ini
    # /lib/systemd/system/space-captain-metrics.socket
    [Unit]
    Description=Space Captain Prometheus Metrics Socket
    
    [Socket]
    ListenStream=9100
    BindIPv6Only=both
    
    [Install]
    WantedBy=sockets.target
    ```
  - Configure service to use socket activation
  - Document firewall rules for metrics endpoint

- **Container-Friendly Monitoring**:
  - Environment variable configuration:
    ```bash
    SPACE_CAPTAIN_METRICS_ENABLED=true
    SPACE_CAPTAIN_METRICS_PORT=9100
    SPACE_CAPTAIN_METRICS_PATH=/metrics
    ```
  - Health check endpoint at `/health`
  - Kubernetes service monitor example
  - Docker Compose monitoring stack example

#### 1.5: Makefile Integration
- Add `make deb` target to the main Makefile that:
  - Builds the Docker image if not present
  - Runs the build container to create package
  - Places the resulting .deb file in a `dist/` directory
- Add `make deb-test` target that:
  - Builds the package
  - Spins up a fresh `debian:12-slim` container
  - Installs the .deb package
  - Verifies the server binary is installed correctly
  - Tests systemd service file presence
- Add `make clean-deb` to remove packaging artifacts

#### 1.6: Testing & Validation
- Build package using the new `make deb` target
- Run `make deb-test` to verify installation on clean Debian 12 container
- Manually test systemd integration on a VM or physical system
- Ensure clean uninstall removes all artifacts

#### 1.7: Local Developer Experience
- **Non-Docker Package Building**:
  - Add `make deb-local` target for developers with local Debian/Ubuntu systems
  - Checks for required build tools: `dpkg-buildpackage`, `debhelper`, `lintian`
  - Example implementation:
    ```makefile
    deb-local: release
        @command -v dpkg-buildpackage >/dev/null || (echo "Please install dpkg-dev" && exit 1)
        @command -v dh >/dev/null || (echo "Please install debhelper" && exit 1)
        dpkg-buildpackage -us -uc -b
        @echo "Package built: ../space-captain-server_*.deb"
    ```

- **Manual Build Instructions**:
  - Document step-by-step process for `dpkg-buildpackage`:
    ```bash
    # Install build dependencies
    sudo apt-get install build-essential debhelper libmbedtls-dev
    
    # Build the package
    dpkg-buildpackage -us -uc -b
    
    # Install the package
    sudo dpkg -i ../space-captain-server_*.deb
    
    # Verify installation
    systemctl status space-captain-server
    ```
  
- **Development Testing Workflow**:
  - Add `make deb-dev` for quick iteration without full packaging
  - Install to temporary location for testing
  - Skip lintian checks for speed during development
  - Preserve debug symbols for development builds

- **Troubleshooting Guide**:
  - Common build errors and solutions:
    - Missing mbedTLS headers: Install `libmbedtls-dev`
    - Debian helper version mismatch: Update `debian/compat`
    - Permission errors: Check file ownership in debian/
  - Debug build failures:
    ```bash
    # Verbose build output
    DH_VERBOSE=1 dpkg-buildpackage -us -uc -b
    
    # Check package contents
    dpkg-deb -c space-captain-server_*.deb
    
    # Verify package metadata
    dpkg-deb -I space-captain-server_*.deb
    ```
  - Testing systemd service locally:
    ```bash
    # Test service file syntax
    systemd-analyze verify debian/space-captain-server.service
    
    # Run service in foreground for debugging
    sudo -u space-captain /usr/bin/space-captain-server
    ```

### Deliverables
- Complete `debian/` directory with all packaging files
- Working `make deb` target in the main Makefile
- Working .deb package that installs and runs on Debian 12
- Documentation for manual package building using `make deb`

---

## Phase 2: GitHub Release Automation (Week 2)

### Goal
Create GitHub Actions workflows that automatically build and publish release artifacts for both x86_64 and AArch64 architectures when a new tag is pushed.

### Tasks

#### 2.1: Build Matrix Setup
- Create `.github/workflows/release.yml`
- Configure build matrix for:
  - x86_64 (amd64) Linux
  - AArch64 (arm64) Linux
- Use appropriate GitHub-hosted runners or QEMU emulation

#### 2.1.1: Reproducible Build Environment
- Pin all Docker base images to specific digests:
  - `debian:12-slim@sha256:...` (update with current stable digest)
  - Document process for updating image digests
- Pin tool versions explicitly:
  - `debhelper` version in Docker build
  - `mbedtls` library version
  - Compiler version (gcc/clang)
- Create `versions.lock` file to track all pinned versions
- Add monthly review process for security updates

#### 2.2: Build and Verification Pipeline
- For each architecture:
  - Build Debian package (.deb)
  - Run `make deb-test` to verify package installation in clean container
  - Build standalone server binary (tarball)
  - Generate SHA256 checksums file
- Only proceed to artifact collection if all tests pass
- Name artifacts with version and architecture:
  - `space-captain-server_0.1.0_amd64.deb`
  - `space-captain-server_0.1.0_arm64.deb`
  - `space-captain-server-0.1.0-linux-amd64.tar.gz`
  - `space-captain-server-0.1.0-linux-arm64.tar.gz`

#### 2.2.1: Build Caching Strategy
- **Docker Layer Caching**:
  - Use `docker/setup-buildx-action` with cache mounts
  - Configure registry-based caching for multi-stage builds
  - Cache base images using `actions/cache` with Docker save/load
  - Example cache configuration:
    ```yaml
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          image=moby/buildkit:latest
          network=host
    - name: Cache Docker layers
      uses: actions/cache@v3
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ hashFiles('docker/debian-build.dockerfile') }}
    ```

- **Build Artifact Caching**:
  - Implement ccache for C compilation with GitHub Actions cache
  - Cache size limit: 500MB per architecture
  - Cache key based on: `${{ runner.os }}-ccache-${{ hashFiles('src/**/*.c', 'src/**/*.h') }}`
  - Mount ccache directory in Docker build container

- **Dependency Caching**:
  - Cache apt package downloads in Docker builds
  - Pin mbedTLS version and cache compiled libraries
  - Cache dependency resolution results
  - Example mbedTLS cache:
    ```yaml
    - name: Cache mbedTLS
      uses: actions/cache@v3
      with:
        path: ~/mbedtls-cache
        key: mbedtls-${{ env.MBEDTLS_VERSION }}-${{ runner.os }}
    ```

- **Cache Warmup Job**:
  - Create separate workflow `cache-warmup.yml`
  - Runs weekly on schedule: `cron: '0 3 * * 1'` (Mondays at 3 AM UTC)
  - Pre-builds Docker images for all architectures
  - Downloads and caches all build dependencies
  - Prunes old cache entries to stay within GitHub's limits
  - Monitors cache hit rates and reports metrics

- **Cache Optimization**:
  - Use cache scoping to separate PR builds from main branch
  - Implement fallback keys for partial cache hits
  - Monitor cache size and implement automatic pruning
  - Document cache invalidation procedures

#### 2.3: Cross-Compilation Strategy
- For AArch64 builds, implement one of:
  - Native compilation on ARM runners (if available)
  - Cross-compilation toolchain setup
  - QEMU-based emulation for package building
- Ensure mbedTLS dependencies are properly handled

#### 2.4: Draft Release Creation
- Trigger on version tags (e.g., `v0.1.0`)
- Create Draft GitHub Release with:
  - Auto-generated changelog from commits
  - All built artifacts attached
  - Installation instructions in release notes
  - SHA256 checksums for verification
- Configure as draft to allow manual review before publishing:
  - Maintainer can review auto-generated notes
  - Verify all artifacts are present and correct
  - Edit release notes if needed
  - Manually publish when ready

#### 2.4.1: Artifact Management
- Configure artifact retention policy:
  - Build artifacts: 30 days retention
  - Failed build logs: 7 days retention
  - Use GitHub Actions `retention-days: 30` for all artifacts
- Implement cleanup workflow:
  - Run weekly to remove old workflow runs
  - Keep only the latest 5 successful builds per branch
  - Preserve all release-tagged builds indefinitely
- Add artifact size monitoring:
  - Alert if package size increases by >10%
  - Track binary size trends over releases

#### 2.4.2: Security Scanning
- **Vulnerability Scanning**:
  - Integrate Trivy scanner in release workflow
  - Scan both Docker images and final binaries
  - Configuration example:
    ```yaml
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: 'dist/'
        format: 'sarif'
        output: 'trivy-results.sarif'
        severity: 'CRITICAL,HIGH,MEDIUM'
        exit-code: '1'  # Fail on HIGH/CRITICAL
    ```
  - Upload SARIF results to GitHub Security tab

- **SBOM Generation**:
  - Use Syft to generate Software Bill of Materials
  - Generate SBOM for each release artifact
  - Include both SPDX and CycloneDX formats
  - Example implementation:
    ```yaml
    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        artifact-name: space-captain-server-${{ matrix.arch }}
        format: spdx-json,cyclonedx-json
        output-file: sbom-${{ matrix.arch }}
    ```
  - Attach SBOMs to GitHub Release artifacts

- **Dependency Checking**:
  - Scan C dependencies with `osv-scanner`
  - Check mbedTLS version against CVE databases
  - Verify system library versions in Docker base image
  - Create allowlist for known false positives
  - Generate dependency report with all versions

- **Security Policy Enforcement**:
  - Block release if CRITICAL vulnerabilities found
  - Require manual approval for HIGH vulnerabilities
  - Document all MEDIUM vulnerabilities in release notes
  - Security check matrix:
    ```yaml
    security-matrix:
      critical: fail
      high: require-approval
      medium: document
      low: log-only
    ```

- **Continuous Security Monitoring**:
  - Schedule daily security scans on latest release
  - Create GitHub issues for new vulnerabilities
  - Send alerts to security mailing list
  - Maintain security advisory page
  - Track time-to-patch metrics

#### 2.5: Post-Release Validation
- Create automated validation workflow triggered after release publishing:
  - Download all release artifacts from GitHub Release
  - For each architecture package:
    - Spin up fresh Debian 12 container
    - Install the .deb package using `dpkg -i`
    - Verify service starts successfully: `systemctl start space-captain-server`
    - Run connectivity test: attempt TCP connection to server port
    - Verify server responds to basic protocol messages
    - Check system resource usage (memory, CPU)
  - For standalone binaries:
    - Extract tarball in clean environment
    - Run binary with `--version` flag
    - Start server and verify basic functionality
- Generate validation report:
  - Success/failure status for each artifact
  - Performance metrics (startup time, memory usage)
  - Any warnings or anomalies detected
  - Post results as comment on GitHub Release
- Notification system:
  - Email maintainers if validation fails
  - Update release notes with validation status
  - Create GitHub issue if critical failures detected

#### 2.6: Multi-Distribution Testing
- **Extended Test Matrix**:
  - Add Ubuntu LTS versions to CI/CD pipeline:
    - Ubuntu 22.04 LTS (Jammy Jellyfish)
    - Ubuntu 24.04 LTS (Noble Numbat)
  - Test on major Debian derivatives:
    - Linux Mint Debian Edition (LMDE)
    - Kali Linux (latest stable)
  - Container matrix configuration:
    ```yaml
    strategy:
      matrix:
        distro:
          - debian:12-slim
          - ubuntu:22.04
          - ubuntu:24.04
          - linuxmintd/mint21-amd64
        arch: [amd64, arm64]
    ```

- **Distribution-Specific Testing**:
  - Verify package dependencies are available in each distro
  - Test systemd service compatibility across versions
  - Check for library version conflicts (especially mbedTLS)
  - Validate user/group creation scripts work correctly
  - Test upgrade paths from older package versions

- **Compatibility Documentation**:
  - Create `docs/distribution-compatibility.md` with:
    - Tested distribution matrix
    - Known issues per distribution
    - Required package repository additions (if any)
    - Distribution-specific installation instructions
  - Example format:
    ```markdown
    ## Debian 12 (Bookworm)
    - Status: ✅ Fully Supported
    - mbedTLS version: 2.28.3
    - Notes: Primary development target
    
    ## Ubuntu 22.04 LTS
    - Status: ✅ Fully Supported
    - mbedTLS version: 2.28.0
    - Notes: Requires libmbedtls14 from universe repository
    ```

- **Automated Compatibility Checks**:
  - Add `check-distro-compat.sh` script to verify:
    - Package manager availability (apt/dpkg)
    - Required library versions
    - Systemd version compatibility
    - Kernel feature requirements
  - Run as pre-install check in package scripts

- **Cross-Distribution Package Testing**:
  - Install packages built on Debian 12 on other distributions
  - Verify no hardcoded paths or assumptions
  - Test with different libc versions
  - Validate portable binary builds work across distros

### Deliverables
- Working GitHub Actions workflow file
- Automated draft releases for both architectures
- Clear documentation on the release process including manual review steps

---

## Success Criteria

1. **Debian Package Quality**
   - Package installs cleanly on fresh Debian 12 systems
   - Server runs as systemd service without manual intervention
   - Package follows Debian packaging best practices
   - Clean uninstall leaves no artifacts

2. **Release Automation**
   - New tags automatically trigger release builds
   - Both architectures build successfully
   - Package verification tests pass in CI for each architecture
   - Artifacts are properly named and versioned
   - Draft releases are created for manual review
   - Release notes are automatically generated but can be edited before publishing

3. **Cross-Platform Support**
   - AArch64 packages work on ARM64 hardware (Raspberry Pi, AWS Graviton)
   - Binary compatibility verified on target platforms
   - Performance characteristics maintained across architectures

---

## Technical Considerations

### Debian Packaging
- Use `debhelper` compat level 13 (Debian 12 standard)
- Ensure proper shared library dependencies
- Consider using `lintian` for package validation

### GitHub Actions
- Use caching for build dependencies
- Implement proper secret management for signing (if needed)
- Consider build time limits and optimization
- Add status badges to README

### Security
- Sign releases with GPG (future enhancement)
- Provide SHA256 checksums for all artifacts
- Document verification procedures
- Consider reproducible builds

---

## Future Enhancements (Not in v1 scope)

- RPM packages for Red Hat-based distributions
- Docker/OCI container images
- Homebrew formula for macOS
- Snap or Flatpak packages
- APT repository hosting
- Automatic version bumping